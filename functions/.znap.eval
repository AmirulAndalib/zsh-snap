#!/bin/zsh
# cache & eval output of command
# args: ( <repo> | <name> ) <command>
zmodload -F zsh/files b:zf_mkdir

if (( $# < 2 )); then
  print -u2 'znap eval: not enough arguments'
  .znap.help eval
  return $(( sysexits[(i)USAGE] + 63 ))
fi

.znap.eval.generate() {
  (
    private line repo=$1 cache_file=$2
    [[ -r $cache_file ]] &&
        IFS='' read -r line < $cache_file
    shift 2
    private header="#${(q)@}"

    if [[ $line != $header ||
        ( -d $repo && -f $repo/${GIT_DIR:-.git}/index &&
            $repo/${GIT_DIR:-.git}/index -nt $cache_file ) ]]; then
      print -r "$header" >| $cache_file
      [[ -d $repo ]] &&
          cd -q -- $repo
      eval "$@" >>| $cache_file
    fi
  )
}

private repo=~znap/$1 cache_dir=$XDG_CACHE_HOME/zsh-snap/eval
[[ $1 == */* ]] &&
    repo=~[$1]
zf_mkdir -pm 0700 $cache_dir
shift
private cache_file=$cache_dir/${repo:t}.zsh

if [[ -r $cache_file ]]; then
  .znap.eval.generate "$repo" "$cache_file" "$@" &|
else
  print -r "znap eval: generating cache for $*"
  .znap.eval.generate "$repo" "$cache_file" "$@"
fi

# Wrap in a named function to prevent private vars from leaking and for profiling purposes.
.znap.eval:${cache_file:t}() {
  . "$1"
}
{
  .znap.eval:${cache_file:t} "$cache_file"
} always {
  unfunction .znap.eval:${cache_file:t}
}
