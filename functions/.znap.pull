#!/bin/zsh
# update repos in parallel
# args: [ <repo> ... ]
zmodload -F zsh/files b:zf_rm
autoload +X -Uz is-at-least

.znap.pull() {
  emulate -L zsh; setopt $_znap_opts

  private -a repos=( ~znap/$^@(D-/) )
  (( ${#repos} )) ||
      repos=( ~znap/*(D-/) )

  .znap.multi '.znap.pull.task '${(i)^repos}
  print -n '\r'
}

.znap.pull.task() {
  emulate -L zsh; setopt $_znap_opts

  .znap.ignore $1:t '*.zwc'  # Add `*.zwc` to repo's local ignore list.

  is-at-least 2.8.0 ${${=$( git --version )}[3]} &&
      private jopt=-j$( ulimit -n )
  git -C $1 fetch -t $jopt --recurse-submodules &>/dev/null ||
      return

  print -n .

  private -a count=( ${="$( git -C $1 rev-list --count --left-right @...@{u} 2>&1 )"} )
  private -i ahead=$count[1] behind=$count[2]
  if (( behind && ! ahead )); then
    cd -q ~znap
    print -nr -- $'\r'"${$( eval "ls -d $1:t" )%[/@]} "
    ..znap.tput el  # Clear to end of line.

    private msg=
    msg="$( git -C $1 pull -q -r $jopt --autostash --recurse-submodules 2>&1 > /dev/null )"
    private err=$?

    print -n '\r'
    .znap.status $1:t
    if (( err )); then
      print $msg
    else
      private cache_dir=$XDG_CACHE_HOME/zsh-snap
      zf_rm -f -- $_comp_dumpfile $cache_dir/fpath/_$1:t $cache_dir/eval/${1:t}.zsh
    fi
  fi
}

.znap.pull "$@"
