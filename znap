#!/bin/zsh
emulate -L zsh -o extendedglob -o NO_shortloops -o warncreateglobal
zmodload zsh/parameter

typeset -gHA _ZNAP_ARGS=(
  cd      'cd to your plugins dir or into a repo'
  clone   'git clone a repo into your plugins dir'
  eval    'eval a command with caching'
  ls      'list your plugins & cache-files, or the contents of a repo'
  path    'print the path to a repo'
  pull    'update all plugins, or a specific one'
  rm      'remove a repo or cache-file'
  source  'source a plugin or theme'
)

local action=$1 plugin=$2 cmd=$3
local -i ret=1

local basedir; zstyle -s ':znap:' plugins-dir basedir ||
  basedir=${${(%):-%x}:A:h:h}
local repo=$basedir/$plugin
local cache=$repo.zsh

case $action in
  cd)
    cd $repo
    ;;
  clone)
    shift 1
    local dir=${XDG_CONFIG_HOME:-$HOME/.config}/zsh/; [[ -d $dir ]] ||
      mkdir -p $dir
    local file=$dir/znap-repos
    local -aU lines=(); [[ -f $file ]] &&
      lines=( ${(f)"$(<$file)"} )
    local -aU repos=( $@ ); (( $#@ > 0 )) ||
      repos=( $lines[@] )
    local -i fd; local -a fds=()
    ret=0
    {
      local r; for r in $repos; do
        exec {fd}< <(
          git -C $basedir clone --recurse-submodules -j$(ulimit -n) \
            --depth=1 --shallow-submodules "$r"
        ); (( ret += ? ))
        fds+=( $fd )
      done
      lines+=( $repos[@] )
      print -l ${(i)lines} >! $file
    } always {
      for fd in $fds; do
        <&$fd; (( ret += ? ))
        exec {fd}<&-; (( ret += ? ))
      done
    }
    return ret
    ;;
  eval)
    {
      setopt interactivecomments shortloops NO_warncreateglobal
      local pwd=$PWD
      local dir=$repo; [[ -d $repo ]] || dir=$basedir

      _znap_cache() {
        print -r "#${(q)cmd}" >! $cache
        eval "cd $dir; $cmd" >>! $cache
      }

      if [[ ! -f $cache ]] || () {
        local -a newer=( $repo/***/*(Ne:'[[ $REPLY -nt $cache ]]:':Y1) )
        [[ -f $newer ]]
      }; then
        _znap_cache
      fi

      local -a lines=( ${(f)"$(<$cache)"} )

      [[ $lines[1] == \#${(q)cmd} ]] || _znap_cache

      eval "cd $dir; ${(F)lines}"
      ret=$?
    } always {
      cd ${pwd:--}
      [[ -v functions[_znap_cache] ]] && unfunction _znap_cache
    }
    return ret
    ;;
  ls)
    {
      _znap_ls() {
        print -n 'ls '
        eval "ls $2 $1; ls -l $1"
      }
      [[ -f $cache ]] &&
        _znap_ls $cache && ret=0
      [[ -z $repo ]] && repo=$basedir
      [[ -d $repo ]] &&
        _znap_ls $repo -d && ret=0
    } always {
      [[ -v functions[_znap_ls] ]] && unfunction _znap_ls
    }
    return ret
    ;;
  path)
    print $repo
    ;;
  pull)
    shift 1
    local -a repos=( $basedir/$^@ ); (( $#@ > 0 )) ||
      repos=( $basedir/*(/) )
    local -i fd; local -a fds=()
    ret=0
    {
      local pwd=$PWD
      cd $basedir
      local r; for r in ${(i)repos}; do
        exec {fd}< <(
          print $(
            eval 'ls -d '$r:t
            git -C $r pull --rebase --recurse-submodules -j$(ulimit -n) 2>&1
            (( ret += ? ))
          )
        )
        fds+=( $fd )
      done
    } always {
      for fd in $fds; do
        <&$fd; (( ret += ? ))
        exec {fd}<&-; (( ret += ? ))
      done
      cd ${pwd:--}
      [[ -v functions[_znap_cache] ]] && unfunction _znap_cache
    }
    return ret
    ;;
  rm)
    shift 1
    (( $#@ > 0 )) || return 1
    local -aU files=()
    for plugin in $@; do
      repo=$basedir/$plugin
      cache=$repo.zsh
      [[ -d $repo ]] && files+="$repo/"
      [[ -f $cache ]] && files+="$cache"
    done
    (( $#files > 0 )) || return 1
    {
      cd $basedir
      local rm=${${commands[trash]:+trash -F}:-rm -r}
      print $rm' '$(eval "ls -d $files[@]:t")
      eval "$rm $files"
    } always {
      cd ${pwd:--}
    }
    ;;
  source)
    setopt shortloops NO_warncreateglobal
    shift 2
    local -aU args=( $repo/$^@ ); (( $#args > 0 )) ||
      args=( $repo )
    local -aU files
    local a; for a in $args; do
      [[ -r $a ]] || continue
      files=( $a ); [[ -d $a ]] &&
        files=(
          $a/(#i){${a:t},${~${${a:t}/(zsh-|-zsh)/}//(-|_)/(-|_)},init,*}.{(|*.)zsh^*.zwc,sh}(#qN.Y1)
        )
      source $files[1]
    done
    ;;
  *)
    print "${(@koF)_ZNAP_ARGS/(#m)*/${(r:8:)MATCH} $_ZNAP_ARGS[$MATCH]}"
    return 1
    ;;
esac
